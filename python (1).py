# -*- coding: utf-8 -*-
"""python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1twNFbBPl2QBgeowlMk6TzL-WqYr9vuN8
"""

# data types

num = input("enter the number")  # to get input same formate for both character and integer
word = input("enter a word")
x=int(56)  # integer
b = str("westworld") # string
f = float(0.96)  # float
mylist = ["clint", "eastwood"] # list
mytuple = ("the", "matrix")
mydic = {"john" : 117 , "locke" : 118}


print(x)
print(b)
print(f)
print(mylist)
print(mytuple)
print(mydic)

# working with strings

mystring = ("hello there")
mystring2 = ( "this is my string")



print(mystring)    #defineing a string

print(mystring[0:1])  #slicing a string

print(mystring2[0:])   # also slicing

print(mystring.upper()) # used to change words into uppercase or lower case

print(mystring.replace("hello","hi"))

print(mystring2.split("an"))

quantity = 3
itemno = 567
price = 49.95
myorder = "I want {} pieces of item {} for {} dollars." # string format options
print(myorder.format(quantity, itemno, price))

myorder = f"I want {quantity} pieces of item {price} for {itemno} dollars." # string format options

myorder

listzero = ["what","nice","how"] # list options
for x in (listzero):
  print(x)

for x in range(10): range option # using range options 
  print(x)

for x in (1*("*"),2*("*"),3*("*"),4*("*"),5*("*")):
  print(x)

for i in range(6):
  print(i * '*')



n = 5
for y in range(5):
  print(" " * (n-y-1) + "*" * (2 *y+1))

# if condition & else condition
talk = input()
if(talk == "hello"):
  print("hello there")
else:
  print("bye")

radio = int(input("what type of song"))
if(radio == 60):
  print("new supplies")
elif(radio == 70):
  print("car battery")
elif(radio == 80):
  print("trouble")
else:
  print("  ")

x = int(input("enter a number "))
while x>10:
  print(x)
  break

i = 1
while i < 6:
  print(i)
  i += 1
else:
  print("i is no longer less than 6")

#for loop 

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)
  if x == "banana":
    break

for i  in range(1,11):
  if(i == 7):break
  print(i)

adj = ["red", "big", "tasty"]
fruits = ["apple", "banana", "cherry"]

for x in adj:
  for y in fruits:
    print(x, y)

my_board()

# FUNCTIONS 

def my_board():
  print("hello")


def simple_calculator():

  x = int(input("enter a number 1:"))
  y = int(input("enter a number 2:"))
  operation = input("enter the operation")
  if ( operation == "add" ):
    print(x + y)
  elif( operation == "sub"):
    print(x - y)
  else:
    print("none")



# creating a class and defining the class to an object

class Dog:

	# A simple class
	# attribute
	attr1 = "mammal"
	attr2 = "dog"

	# A sample method
	def fun(self):
		print("I'm a", self.attr1)
		print("I'm a", self.attr2)


# Driver code
# Object instantiation
Rodger = Dog()

# Accessing class attributes
# and method through objects
print(Rodger.attr1)
Rodger.fun()

# trained model for keras 

import keras
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D
from keras import backend as K

# Set batch size, number of classes, and number of epochs
batch_size = 128
num_classes = 10
epochs = 12

# Input image dimensions
img_rows, img_cols = 28, 28

# Load the MNIST dataset
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# Reshape the input data depending on the backend being used
if K.image_data_format() == 'channels_first':
    x_train = x_train.reshape(x_train.shape[0], 1, img_rows, img_cols)
    x_test = x_test.reshape(x_test.shape[0], 1, img_rows, img_cols)
    input_shape = (1, img_rows, img_cols)
else:
    x_train = x_train.reshape(x_train.shape[0], img_rows, img_cols, 1)
    x_test = x_test.reshape(x_test.shape[0], img_rows, img_cols, 1)
    input_shape = (img_rows, img_cols, 1)

# Convert the data to float32 and scale it to be between 0 and 1
x_train = x_train.astype('float32')
x_test = x_test.astype('float32')
x_train /= 255
x_test /= 255

# Convert the class vectors to binary class matrices
y_train = keras.utils.to_categorical(y_train, num_classes)
y_test = keras.utils.to_categorical(y_test, num_classes)

# Define the CNN model
model = Sequential()
model.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=input_shape))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))
model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(num_classes, activation='softmax'))

# Compile the model
model.compile(loss=keras.losses.categorical_crossentropy,
              optimizer=keras.optimizers.Adadelta(),
              metrics=['accuracy'])

# Train the model
model.fit(x_train, y_train,
          batch_size=batch_size,
          epochs=epochs,
          verbose=1,
          validation_data=(x_test, y_test))

# Evaluate the model on the test data
score = model.evaluate(x_test, y_test, verbose=0)
print('Test loss:', score[0])
print('Test accuracy:', score[1])